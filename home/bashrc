#
# klange's ~/.bashrc
#

[ -z "$PS1" ] && return

# DEFAULTS
KLANGE_USE_GIT=false
KLANGE_USE_SVN=false
KLANGE_USE_HG=false

if [[ "$(uname)" == "Darwin" || "$(uname)" == *CYGWIN* ]] ; then
	HOSTNAME=`hostname`
	alias ls="ls -G"
	export PATH="/Applications/Xcode.app/Contents/Developer/usr/bin:$PATH"
else
	HOSTNAME=`hostname --long`
fi

KLANGE_USE_GIT=true

# HOST OPTIONS
case $HOSTNAME in
	luka|kaito|miku|rin|len|piko)
		KLANGE_USE_GIT=true
		KLANGE_USE_SVN=true
		KLANGE_USE_HG=true
		if [[ "$(uname)" == *CYGWIN* ]] ; then
			KLANGE_USE_GIT=false
			KLANGE_USE_SVN=false
			KLANGE_USE_HG=false
		fi
		;;
	*.yelpcorp.com)
		KLANGE_USE_GIT=true
		;;
	*.acm.uiuc.edu|*.acm.illinois.edu)
		KLANGE_USE_GIT=true
		alias conkyForecast="python conkyForecast/conkyForecast.py"
		export PATH=/afs/acm.uiuc.edu/admin/scripts:$PATH
		;;
	*.ews.illinois.edu|*.ews.uiuc.edu)
		KLANGE_USE_GIT=false
		KLANGE_USE_SVN=true
		alias cs232=/homesta/classdata/bin/cs232
		alias sudo="echo This is an EWS workstation. You do not have 'sudo' here. #"
		alias vim=vimx
		;;
	*.cs.illinois.edu|*.cs.uiuc.edu)
		KLANGE_USE_GIT=true
		KLANGE_USE_SVN=false
		if [[ "x$HOME" == "x/home/$USER" ]] ; then
			if [ -e /expand/home ] ; then
				export HOME=/expand/home/$USER
			fi
		fi
		;;
esac

KLANGE_EXPAND_GIT=false

# ~/bin
if [ -e ~/bin ]; then
	export PATH=~/bin:$PATH
fi

# SPECIAL OPTIONS AND FIXES

export HISTCONTROL=$HISTCONTROL${HISTCONTROL+,}ignoredups
export HISTCONTROL=ignoreboth
shopt -s histappend
shopt -s checkwinsize
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
	debian_chroot=$(cat /etc/debian_chroot)
fi

# Fix gnome-terminal color support
if [ "$COLORTERM" == "gnome-terminal" ]; then
	export TERM="xterm-256color"
elif [ "$COLORTERM" == "mate-terminal" ]; then
	export TERM="xterm-256color"
elif [ "$COLORTERM" == "Terminal" ]; then
	# XFCE Terminal
	export TERM="xterm-256color"
elif [ "$FBTERM" == "1" ]; then
	export TERM="fbterm"
elif [ "$TERM" == "xterm" ]; then
	# If shell reports just 'xterm', it may be PuTTY
	if [ -e ~/bin/answerback ]; then
		export ANSWERBACK=$(~/bin/answerback)
		if [ "x$ANSWERBACK" == "xPuTTY" ]; then
			export TERM="xterm-256color"
			export COLORTERM="putty-256color"
			export LANG="C"
		fi
	fi
fi

if [ "$TERMINAL_OVERRIDE" != "" ]; then
	# Some things just refuse to accept their own
	# configuration options for these things.
	export TERM=$TERMINAL_OVERRIDE
fi

# Tango palette for framebuffers
function color_palette () {
	echo -en "\e]P02e3436" #black
	echo -en "\e]P8555753" #darkgray
	echo -en "\e]P1cc0000" #darkred
	echo -en "\e]P9ef2929" #red
	echo -en "\e]P24e9a06" #darkgreen
	echo -en "\e]PA8ae234" #green
	echo -en "\e]P3c4a000" #brown
	echo -en "\e]PBfce94f" #yellow
	echo -en "\e]P43465a4" #darkblue
	echo -en "\e]PC729fcf" #blue
	echo -en "\e]P575507b" #darkmagenta
	echo -en "\e]PDad7fa8" #magenta
	echo -en "\e]P606989a" #darkcyan
	echo -en "\e]PE34e2e2" #cyan
	echo -en "\e]P7ffffff" #lightgray
	echo -en "\e]PFeeeeec" #white
}
if [ "$TERM" == "linux" ]; then
	color_palette
fi

if [ "$TERM" == "screen-bce" ]; then
	# I use screen under 256-color-supportive things
	# far more often than not, so give me 256-colors
	export TERM=screen-256color
fi
# PROMPT

function prompt_command_old {
	# [user host MM/DD HH:MM /path/to/us]
	# $ *
	local RETURN_CODE="$?"
	local ASCII_RESET="\[\e[0m\]"
	local ASCII_BOLD="\[\e[1m\]"
	local USER_COLOR="\[\e[1;33m\]"
	local PROMPT_COLOR="\[\e[1;32m\]"
	if [[ ${EUID} == 0 ]] ; then
		PROMPT_COLOR="\[\e[1;31m\]"
	fi
	local HOST_COLOR="\[\e[1;32m\]"
	local DATE_COLOR="\[\e[1;31m\]"
	local TIME_COLOR="\[\e[1;34m\]"
	local DATE_STRING="\$(date +%m/%d)"
	local TIME_STRING="\$(date +%H:%M:%S)"
	local CYAN_COLOR="\[\e[1;36m\]"
	local PINK_COLOR="\[\e[1;35m\]"
	# user and host
	local PROMPT_PREFIX=""
	local USER_HOST="$USER_COLOR\u $HOST_COLOR\h"
	PROMPT_PREFIX="$PROMPT_PREFIX$USER_HOST "
	# Paths
	local CURRENT_PATH="\w"
	if [ -e ~/bin/shorten_pwd ] ; then
		CURRENT_PATH=`~/bin/shorten_pwd`
	fi
	if [ "$WINDOW" != "" ] ; then
		PROMPT_PREFIX="$PROMPT_PREFIX$PINK_COLOR%$WINDOW "
	fi
	local DATE_STRING="$DATE_COLOR$DATE_STRING $TIME_COLOR$TIME_STRING "
	PROMPT_PREFIX="$PROMPT_PREFIX$DATE_STRING"
	# Screen window number
	# Return code
	if [[ $RETURN_CODE != 0 ]] ; then
		PROMPT_PREFIX="$PROMPT_PREFIX$DATE_COLOR$RETURN_CODE$ASCII_RESET " # do nothing
	fi
	# Title bar
	local TITLEBAR=""
	case $TERM in
		xterm*|*rxvt*|cygwin|interix|Eterm|mlterm|kterm|aterm|putty*)
			if [ "${STY}" ] ; then
				 TITLEBAR="\[\ek\u@\h:$CURRENT_PATH\e\134\]"
			else
				TITLEBAR="\[\e]1;\u@\h:$CURRENT_PATH\007\e]2;\u@\h:$CURRENT_PATH\007\]"
			fi
		;;
		screen*)
			TITLEBAR="\[\ek\u@\h:$CURRENT_PATH\e\134\]"
		;;
	esac
	# Git support
	if [ $KLANGE_USE_GIT == true ]; then
		local GIT_STATUS="$(git status 2>/dev/null)"
		if [[ $GIT_STATUS != "" ]] ; then
			local REFS=" $(git symbolic-ref HEAD 2>/dev/null | sed 's/.*\///')"
			REFS="${REFS#refs/heads/}"
			if [[ `echo $GIT_STATUS | grep "modified:"` != "" ]] ; then
				REFS="$REFS$ASCII_RESET ${PINK_COLOR}m" # Modified
				if [ $KLANGE_EXPAND_GIT == true ]; then
					REFS="${REFS}odified"
				fi
			elif [[ `echo $GIT_STATUS | grep "renamed:"` != "" ]] ; then
				REFS="$REFS$ASCII_RESET ${PINK_COLOR}m" # Modified as well
				if [ $KLANGE_EXPAND_GIT == true ]; then
					REFS="${REFS}odified"
				fi
			fi
			if [[ `echo $GIT_STATUS | grep "ahead of"` != "" ]] ; then
				REFS="$REFS$ASCII_RESET ${CYAN_COLOR}s" # Staged
				if [ $KLANGE_EXPAND_GIT == true ]; then
					REFS="${REFS}taged"
				fi
			fi 
			if [ $KLANGE_EXPAND_GIT == true ]; then
				local COMMIT=`git show | head -1 | sed 's/commit //'`
				REFS="$REFS $TIME_COLOR[$ASCII_RESET$COMMIT$TIME_COLOR]"
				if [[ `echo $GIT_STATUS | grep "Untracked"` != "" ]] ; then
					REFS="$REFS$DATE_COLOR untracked files"
				fi
				if [[ `echo $GIT_STATUS | grep "new file"` != "" ]] ; then
					REFS="$REFS$HOST_COLOR new files"
				fi
			fi
			PROMPT_PREFIX="$PROMPT_PREFIX${HOST_COLOR}git$USER_COLOR$REFS$ASCII_RESET "
		fi
	fi
	#
	local FINAL_PATH="$ASCII_RESET$CURRENT_PATH"
	PROMPT_PREFIX="$PROMPT_PREFIX$FINAL_PATH"
	# And we're done
	PS1="$TITLEBAR$ASCII_BOLD[$PROMPT_PREFIX$ASCII_BOLD]$ASCII_RESET\n$PROMPT_COLOR\\\$$ASCII_RESET "
}
function prompt_command {
	local RETURN_CODE="$?"

	local COLOR_P="\033[38;5;"
	local COLOR_A="m"
	if [ "$TERM" == "fbterm" ] ; then
		COLOR_P="\033[1;"
		COLOR_A="}"
	fi
	local   SOFT_YELLOW="\[${COLOR_P}221$COLOR_A\]"
	local   MEDIUM_GRAY="\[${COLOR_P}59$COLOR_A\]"
	local     SOFT_BLUE="\[${COLOR_P}81$COLOR_A\]"
	local    LIGHT_GRAY="\[${COLOR_P}188$COLOR_A\]"
	local    LIGHT_GOLD="\[${COLOR_P}222$COLOR_A\]"
	local MEDIUM_ORANGE="\[${COLOR_P}173$COLOR_A\]"
	local    MEDIUM_RED="\[${COLOR_P}167$COLOR_A\]"
	local  MEDIUM_GREEN="\[${COLOR_P}47$COLOR_A\]"
	local    BRIGHT_RED="\[${COLOR_P}196$COLOR_A\]"
	local  LIGHT_PURPLE="\[${COLOR_P}177$COLOR_A\]"
	local         RESET="\[\033[0m\]"
	local          BOLD="\[\033[1m\]"
	local          SAVE="\[\033[s\]"
	local       RESTORE="\[\033[u\]"

	if [ "$TERM" == "linux" ] ; then
		  SOFT_YELLOW="\[\033[1;33m\]"
		  MEDIUM_GRAY="\[\033[1;30m\]"
			SOFT_BLUE="\[\033[1;34m\]"
		   LIGHT_GRAY="\[\033[1;30m\]"
		   LIGHT_GOLD="\[\033[1;33m\]"
		MEDIUM_ORANGE="\[\033[1;33m\]"
		   MEDIUM_RED="\[\033[1;31m\]"
		 MEDIUM_GREEN="\[\033[1;32m\]"
		   BRIGHT_RED="\[\033[1;31m\]"
		 LIGHT_PURPLE="\[\033[1;35m\]"
	fi

	local ALIGN_LEFT="\033[1G"
	local ALIGN_RIGHT="\033[400C"
	local MAKE_SPACE="\033[16D"

	local DATE_STRING="\D{%m/%d}"
	local TIME_STRING="\t"

	local CURRENT_PATH="\w"
	if [ -e ~/bin/shorten_pwd ] ; then
		CURRENT_PATH=`~/bin/shorten_pwd`
	fi

	local TITLEBAR=""
	case $TERM in
		xterm*|*rxvt*|cygwin|interix|Eterm|mlterm|kterm|aterm|putty*)
			if [ "${STY}" ] ; then
				 TITLEBAR="\[\ek\u@\h:$CURRENT_PATH\e\134\]"
			else
				TITLEBAR="\[\e]1;\u@\h:$CURRENT_PATH\007\e]2;\u@\h:$CURRENT_PATH\007\]"
			fi
		;;
		toaru*)
			TITLEBAR="\[\e]1;\u@\h:$CURRENT_PATH\007\]"
		;;
		screen*)
			TITLEBAR="\[\ek\u@\h:$CURRENT_PATH\e\134\]"
		;;
	esac

	local PROMPT_COLOR="$MEDIUM_GREEN"
	if [[ ${EUID} == 0 ]] ; then
		PROMPT_COLOR="$BRIGHT_RED"
	fi

	local PROMPT="$BOLD"
	PROMPT="$PROMPT$SAVE\[$ALIGN_RIGHT$MAKE_SPACE\]" # Ram the cursor to the right, then back 16 spaces
	PROMPT="$PROMPT$MEDIUM_GRAY\[[\]$MEDIUM_ORANGE\[$DATE_STRING \]$MEDIUM_RED\[$TIME_STRING\]$MEDIUM_GRAY\[]\]"
	PROMPT="$PROMPT$RESTORE" # Reset the cursor to the left side
	PROMPT="$PROMPT$SOFT_YELLOW\u$MEDIUM_GRAY@$SOFT_BLUE\h "

	if [ $KLANGE_USE_GIT == true ]; then
		local GIT_STATUS="$(git status 2>/dev/null)"
		if [[ $GIT_STATUS != "" ]] ; then
			local REFS="$(git symbolic-ref HEAD 2>/dev/null | sed 's/.*\///')"
			REFS="$LIGHT_GOLD${REFS#refs/heads/}"
			if [[ `echo $GIT_STATUS | grep "modified:"` != "" ]] ; then
				REFS="$REFS$LIGHT_PURPLE*" # Modified
			elif [[ `echo $GIT_STATUS | grep "renamed:"` != "" ]] ; then
				REFS="$REFS$LIGHT_PURPLE*" # Modified as well
			fi
			if [[ `echo $GIT_STATUS | grep "ahead of"` != "" ]] ; then
				REFS="$REFS$SOFT_BLUE^" # Staged
			fi 
			PROMPT="$PROMPT$REFS "
		fi
	fi

	if [[ $RETURN_CODE != 0 ]] ; then
		PROMPT="$PROMPT$MEDIUM_RED$RETURN_CODE "
	fi

	PROMPT="$PROMPT$RESET$LIGHT_GRAY$CURRENT_PATH$BOLD$PROMPT_COLOR\\\$ $RESET"
	PS1="$TITLEBAR$PROMPT"
}

export PROMPT_COMMAND=prompt_command

# COLOR SUPPOORT

if [ -x /usr/bin/dircolors ]; then
	eval "`dircolors -b`"
	alias ls='ls --color=auto'
fi

# TAB COMPLETION

if [ -f /etc/bash_completion ]; then
	. /etc/bash_completion
fi

# ALIASES

alias なの="LANG=ja_JP.utf8 nano"
alias rape='fsck -f'
alias ll='ls -l'
alias la='ls -la'

# EDITOR

export EDITOR=vim

gvim(){ setsid /usr/bin/gvim -f "$@"; }

# FUNCTIONS

generate_password () {
	cat /dev/urandom| tr -dc 'a-zA-Z0-9' | fold -w $1 | head -n 1
}

generate_password_rich () {
	cat /dev/urandom| tr -dc '[:graph:]' | fold -w $1 | head -n 1
}

pecho () {
	if [ "$1" == "" ]; then
		echo 'Usage: pecho [window_number [window_number [...]]]'
		return 1
	fi
	echo -e "\e[1m[echoing in parallel on screens $@]\e[0m"
	stty -echo
	while IFS= read -r -s -n1 c; do
		for screen in $@; do
			if [ "$c" == "" ]; then
				screen -X -p $screen stuff $'\012'
			else
				screen -X -p $screen stuff $"$c"
			fi
		done
	done
}

toaru-fix-path() {
	export PATH="/home/klange/osdev/util/toaru-toolchain/bin:$PATH"
}

# CUSTOM TAB COMPLETIONS

# Caffeine `caffeinate` Script -> netids (usernames)
tc_caffeinate () {
	local curw
	COMPREPLY=()
	curw=${COMP_WORDS[COMP_CWORD]}
	COMPREPLY=($(compgen -A user -- $curw))
	return 0
}
complete -F tc_caffeinate -o dirnames caffeinate

tc_generate_password () {
	local curw
	COMPREPLY=()
	curw=${COMP_WORSD[COMP_CWORD]}
	COMPREPLY=($(compgen -W '8 10 12 15' -- $curw))
	return 0
}
complete -F tc_generate_password generate_password
complete -F tc_generate_password generate_password_rich

alias :qall="echo \"This isn't vim :P\" && exit"
